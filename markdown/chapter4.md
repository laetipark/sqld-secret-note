### 데이터 모델과 성능
#### 성능 데이터 모델링
- 데이터베이스의 성능 향상을 목적으로, 데이터 모델 설계 시점부터 정규화, 반정규화, 테이블 통합, 테이블 분할, 조인 구조, PK, FK 등 여러 가지 성능과 관련된 사항들이 데이터 모델링 작업에 반영될 수 있도록 하는 것
- 성능 저하에 대한 비용을 최소화 시킬 수 있으며 시스템 구축 프로젝트 전체 일정에서 가장 앞 단계에서 할수록 성능 저하에 따른 비용을 감소시킬 수 있음
- 분석/설계 -> 구현 -> 테스트 -> 운영 단계로 시간이 지날수록 비용이 증가
- 성능 데이터 모델링 고려사항
  - 데이터 모델링 시 정규화 작업을 수행
  - 데이터베이스의 용량을 산정
  - 데이터베이스에 발생되는 트랜잭션 유형을 파악
  - 데이터베이스의 용량 및 트랜잭션의 유형에 따라 반정규화 수행
  - 이력 데이터 모델의 조정, PK/FK 조정, 슈퍼/서브 타입 변환 조정 등 수행
  - 성능 관점에서 데이터 모델 검증

#### 정규화
- 데이터를 결정하는 결정자에 의해 함수적 종속을 가지고 있는 일반 속성을 의존자로 하여 입력/수정/삭제 이상현상 제거
- 정규화 용어
  - 정규화(Normalization) : 함수적 종속성(FD) 등과 같은 이론에 근거해 관계형 데이터베이스 테이블의 삽입/삭제/갱신 이상 현상 발생을 최소화하기 위해 좀 더 작은 단위의 테이블로 설계하는 과정, 데이터 모델을 정규형에 맞도록 고치는 과정
  - 정규형(NF, Normal Form) : 정규화 결과에 의해 도출된 데이터 모델이 갖춰야 할 특성을 만족한 형태
  - 함수적 종속성(FD, Functional Dependency) : 테이블 특정 열 A의 값을 알면 다른 B값을 알 수 있을 때 B열은 A열에 함수적 종속성이 있다고함
  - 결정자(Determinant) : 함수적 종속성 설명에서 A열을 결정자라함
  - 다치종속(MVD, MultiValued Dependency) : 결정자 A열에 의해 B열의 값을 다수 알 수 있을 때, B열은 A열에 다치종속되었다고함
- 정규화의 장점 : 높은 응집도/낮은 결합도(High Cohesion & Looses Coupling) 원칙에 충실해지며 유연성 극대화, 중복의 최소화
- 정규화 이론
  - 제1정규화 : 한 속성에 여러 개의 속성값을 갖거나 같은 유형의 속성이 여러 개인 경우 해당 속성을 분리, 속성의 원자성 확보
  - 제2정규화 : 주식별자에 의해 완전 함수 종속되지 않은 속성을 분리, 부분 종속 속성(Partial Dependency Attribute)이 된 속성을 분리
  - 제3정규화 : 일반 속성끼리 함수 종속이 발생한 속성을 분리, 이행적 종속 속성(Transitive Dependency Attribute)을 분리
  - 보이스-코드 정규화(BCNF, Boyce-Codd Normal Form) : 결정자 안에 함수 종속을 가진 주식별자 속성을 분리
  - 제4정규화 : 다치 종속(Multi-Valued Dependency) 속성을 별도의 엔터티로 분리
  - 제5정규화 : 결합 종속(Join Dependency)일 경우 2개 이상의 엔터티로 분리
- 정규화의 성능 : 과도하게 많은 인덱스가 만들어지는 현상을 막을 수 있으며, 성능상 유리해짐

#### 반정규화
- 정규화된 데이터 모델을 분석해 엔터티/속성/관계를 중복, 통합, 분리 등 작업으로 수행하는 데이터 모델링 기법
- 데이터를 고의적으로 중복 저장하여 조인 연산이 회피되어 조회 성능을 향상시킴
- 데이터를 조회할 때 디스크 I/O량이 많아 성능이 저하되거나 테이블 간 경로가 너무 멀어 조인으로 인한 성능 저하가 에상되는 경우, 그리고 열을 계산해 읽을 때 성능이 저하될 것이 예상되는 경우 사용
- 반정규화 절차 
  1. 반정규화 대상 조사
     - 범위 처리 빈도수 조사
     - 대량의 범위 처리 조사
     - 통계성 프로세스 조사
     - 테이블 조인 개수
  2. 다른 방법 유도 검토
     - 뷰 테이블
     - 클러스터링 적용
     - 인덱스 조정
     - 응용 애플리케이션 변경
   3. 반정규화 적용
     - 테이블 반정규화
     - 속성의 반정규화
     - 관계의 반정규화
- 반정규화 기법
  - 테이블 병합
    - 1:1 관계 테이블 병합 : 1:1 관계를 통합하여 성능 향상시키는 기법, 2개의 테이블을 하나의 테이블로 병합해 테이블 간 조인 연산 제거
    - 1:M 관계 테이블 병합 : 1:M 관계를 통합하여 성능 향상시키는 기법, 2개의 테이블을 하나의 테이블로 병합해 테이블 간 조인 연산 제거
    - 슈퍼/서브 타입 테이블 병합 : 슈퍼/서브 관계를 통합해 성능을 향상시키는 기법, 슈퍼/서브 타입 관계를 하나의 테이블로 병합해 조인 연산 제거
  - 테이블 분할
    - 수직 분할 : 열 단위 테이블을 디스크 I/O 분산 처리하기 위해 테이블을 1:1로 분리해 성능 향상시키는 방법, 트랜잭션이 처리되는 유형 파악이 선행되어야함
    - 수평 분할 : 행 단위 집중 발생되는 트랜잭션을 분석하여 디스크 I/O 및 데이터 접근 효율을 높여 성능을 향상하기 위해 행 단위로 테이블을 쪼개는 방법
  - 테이블 추가
    - 중복 테이블 추가 : 다른 업무이거나 서버가 다른 경우 동일한 테이블 구조를 중복하고 원격 조인을 제거해 성능 향상
    - 통계 테이블 추가 : SUM, AVG 등을 미리 수행해 계산해둠으로써 조회 시 성능 향상
    - 이력 테이블 추가 : 이력 테이블 중 마스터 테이블에 존재하는 레코드를 중복하여 이력 테이블에 저장하는 반정규화 기법
    - 부분 테이블 추가 : 특정 테이블에서 전체 열 중 자주 조회하는 집중화된 열이 있을 때, 디스크 I/O를 줄이기 위해 해당 열들을 모아놓은 별도의 반정규화된 테이블
- 열 반정규화 기법
  - 중복 열 추가 : 조인 연산으로 인한 성능 저하를 예방하기 위해 중복 열을 추가해 조인 연산을 하지 않도록함
  - 파생 열 추가 : 트랜잭션이 처리되는 계산에 의해 발생되는 값의 성능 저하를 예방하기 위해 미리 값을 계산해 열에 보관
  - 이력 테이블 열 추가 : 대량의 이력 데이터를 처리할 때 불특정 날 조회나 최근 값을 조회할 때 나타날 수 있는 성능 저하를 예방하기 위해 이력 테이블에 열 추가
  - PK에 의한 열 추가 : 복합의미를 갖는 PK를 단일 속성으로 구성하였을 경우 단일PK 안에서 특정 값을 별도로 조회하는 경우 성능 저하가 발생할 수 있음
  - 응용 시스템의 오작동을 위한 열 추가 : 비즈니스적으로 의미가 없지만 사용자가 데이터 처리를 하다가 잘못 처리하여 원래의 값으로 복구를 원하는 경우 이전 데이터를 임시적으로 중복해 보관하는 기법, 이것을 데이터 모델로 풀어내면 정상적인 데이터 모델 기법으로 이용 가능
- 관계 반정규화 기법 : 데이터 처리를 위한 여러 경로를 거쳐 조인이 가능하지만, 이때 발생할 수 있는 성능 저하를 예방하기 위해 추가적인 관계를 맺는 방법

#### 대량 데이터에 따른 성능
- 대량의 데이터가 존재하는 테이블에는 많은 트랜잭션이 발생하며 성능 저하될 수 있음
- 수평/수직 분할 설계를 통해 성능 저하를 예방할 수 있음
- 성능 저하 현상 : 절대적으로 읽어야할 데이터 블록의 수가 늘어나면서 성능 저하됨
  - 로우 체이닝(Row Chaining) : 로우 길이가 너무 길어져 데이터 블록 하나에 데이터가 모두 저장되지 않고 2개 이상의 블록에 걸쳐 하나의 로우가 저장되어있는 형태
  - 로우 마이그레이션(Row Migration) : 데이터 블록에서 수정이 발생하면 수정된 데이터를 해당 데이터 블록에서 저장하지 못하고, 다른 블록의 빈 공간을 찾아 저장하는 방식
- 수평 분할 : 행 단위로 분할해 I/O를 감소시키는 방법
  - 범위 파티셔닝 : 특정 기간으로 분할하는 방식
  - 리스트 파티셔닝 : 특정 열로 분류하여 분할하는 방식
  - 해시 파티셔닝 지정된 HASH 조건에 따라 해싱 알고리즘을 적용해 테이블을 분리, 
- 수직 분할 : 열 단위로 분할해 I/O를 감소시키는 방법
  - 테이블 수직 분할 : 매우 많은 열을 가지고 있는 경우 테이블을 나누어 읽어들이는 블록 I/O 개수를 줄이는 방식
- 수평/수직 분할 절차
  1. 데이터 모델링 완성
  2. 데이터베이스 각 테이블의 용량 산정
  3. 대량의 데이터가 처리되는 테이블에 대해 트랜잭션 처리 패턴을 만듦
  4. 열 단위로 집중화된 처리가 발생하는지, 로우 단위로 집중화된 처리가 발생하는지 분석해 처리 작업이 집중화된 단위로 테이블 분리 검토

#### 데이터베이스 구조와 성능
- 슈퍼/서브 타입 모델
  - 업무를 구성하는 데이터의 특징을 분석해 공통점과 차이점을 고려해 효과적 표현
  - 공통의 부분을 슈퍼 타입 엔터티로 도출하고 공통으로부터 상속받아 다른 엔터티와 차이가 있는 속성에 대해서는 별도의 서브 타입 엔터티로 구분하는 방식
  - 데이터 양과 트랜잭션 유형을 기준으로 슈퍼/서브 개별 타입으로 변환
  - 슈퍼 타입(Single 타입, All in One 타입) : 슈퍼/서브 타입 모델을 **하나의 테이블**로 변환한 것
    - 트랜잭션은 항상 슈퍼 타입 기준으로 처리하는데 테이블은 개별 타입으로 유지되며 UNION 연산에 의해 성능이 저하될 수 있음 -> 슈퍼 타입 기준으로 테이블 구성
    - 확장성 : 나쁨
    - 조인 성능: 우수함
    - I/O 성능 : 나쁨
    - 관리 용이성 : 좋음
    - 전체를 일괄적으로 처리할 때 선택
  - 서브 타입(Plus 타입, Super + Sub 타입) : 슈퍼/서브 타입을 **서브 타입 테이블들**로 변환한 것으로, 도출된 각각의 서브 타입에는 변환 전 슈퍼 엔터티에 있던 칼럼들을 공통적으로 가짐
    - 트랜잭션은 항상 서브 타입 기준으로 처리하는데 슈퍼 타입으로 되어 있는 경우 성능이 저하되는 경우가 있음 -> 서브 타입 기준으로 테이블 구성
    - 확장성 : 보통
    - 조인 성능: 나쁨
    - I/O 성능 : 좋음
    - 관리 용이성 : 좋지 않음
    - 각각의 서브 타입을 기준으로 처리하는 경우 선택
  - 개별 타입(OneToOne 타입, 1:1 타입) : 슈퍼/서브 타입을 슈퍼 타입과 서브 타입의 각각 개별 테이블로 변환한 것으로, 슈퍼 테이블, 서브 테이블 모두 생성한 것
- 슈퍼/서브 타입 모델 변환 이유
  - 트랜잭션은 항상 개별 타입 기준으로 처리하는데, 테이블은 슈퍼 타입으로 되어있어서 불필요하게 많은 데이터가 집약되어 성능이 저하되는 경우가 있음 -> 개별 타입 기준으로 테이블 구성
  - 확장성 : 좋음
  - 조인 성능: 나쁨
  - I/O 성능 : 좋음
  - 관리 용이성 : 좋지 않음
  - 각각의 슈퍼, 서브 타입을 기준으로 처리하는 경우 선택
- 복합PK열 : 순서에 따라 SQL문의 성능이 달라질 수 있음
  - A,B,C,D PK열에서 B,C,D 열로 조건값을 주는 경우가 대부분일 경우 B,C,D,A 순으로 변경하면 테이블을 모두 스캔하는 현상을 방지해 성능 향상 효과를 누릴 수 있음
  - 범위 조회 조건의 열일 경우 일치 조건의 열보다 뒤로 하여 성능 향상 효과를 누릴 수 있음
- FK 제약조건이 있는 경우 외래키 열에 대한 인덱스 생성이 유리

#### 분산 데이터베이스
- 여러 곳으로 분산되어 있는 데이터베이스를 하나의 가상 시스템으로 사용할 수 있도록 한 데이터베이스
- 물리적으로 분산되어 있는 데이터들의 모임
- 분산 데이터베이스의 투명성
  - 분할 투명성
    - 하나의 논리적 Relation이 여러 단편으로 분할되어 각 단편의 사본이 여러 Site에 저장
    - 사용자는 논리적 테이블이 한 곳에 위치하는 것으로 인식해야함
  - 위치 투명성
    - 사용하려는 데이터의 저장 장소를 명시할 필요가 없음
    - 위치정보가 System Catalog에 유지되어야함, 데이터 위치에 대해 신경 쓸 필요가 없는 것
  - 지역 사상 투명성
    - 지역 DBMS와 물리적 DB 사이 Mapping을 보장
    - 각 지역 시스템 이름과 무관한 이름 사용 가능
    - 해당 데이터 어느 지역에 위치하는지를 신경 쓸 필요가 없음
  - 중복 투명성
    - DB 객체가 여러 Site에 중복되어 있는지 사용자는 전혀 알 필요 없는 성질
  - 장애 투명성
    - 구성요소(DBMS, Computer)의 장애와 무관한 Transaction의 원자성 유지
    - 분산 DB의 장애상황과는 무관하게 원자성을 유지해야함
  - 병행 투명성
    - 다수 Transaction이 동시에 수행 시 결과의 일관성을 유지(Locking, Time, Stamp 방)
- 분산 데이터베이스의 장단점
  - 장점
    - 지역자치성, 점증적 시스템 용량 확장
    - 신뢰성과 가용성
    - 효용성과 융통성
    - 빠른 응답 속도와 통신비용 절감
    - 데이터의 가용성과 신뢰성 증가
    - 시스템 규모의 적절한 조절
    - 각 지역 사용자의 요구 수용 증대
  - 단점
    - 소프트웨어 개발 비용
    - 오류의 잠재성 증대
    - 처리 비용 증대
    - 설계 및 관리의 복잡성과 비용
    - 불규칙한 응답 속도
    - 통제의 어려움
    - 데이터 무결성에 대한 위협
- 분산 데이터베이스 적용 기법
  - 테이블 위치(Location) 분산 : 설계된 테이블 위치를 각각 다르게 위치시키는 것
  - 테이블 분할(Fragmentation) 분산 : 각각의 테이블을 쪼개어 분산하는 방법
    - 수평 분할 : 노드에 따라 테이블을 특정 열 값을 기준으로 행 분리
    - 수직 분할 : 노드에 따라 테이블 열을 기준으로 열 분리하며 행 단위로 분리되지 않음
  - 테이블 복제(Replication) 분산 : 동일한 테이블을 다른 지역이나 서버에 동시에 생성하여 관리하는 유형
    - 부분복제 : 통합된 테이블을 한 군데에 가지고 있으면서 각 노드별로 노드에 해당된 행을 가지고 있는 형태
    - 광역복제 : 통합된 테이블을 한 군데에 가지고 있으면서 각 노드에도 동일한 데이터를 모두 가지고 있는 형태
  - 테이블 요약(Summarization) : 지역 간 또는 서버 간 데이터가 비슷하지만 서로 다른 유형으로 존재하는 경우
    - 분석요약 : 각 노드별 존재하는 요약정보를 통합해 다시 전체에 대해 요약 정보를 산출하는 분산 방법
    - 통합요약 : 각 노드별 존재하는 다른 내용의 정보를 통합해 다시 전체에 대해 요약정보를 산출하는 분산 방법